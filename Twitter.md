### 步骤 1：明确需求

功能性需求

推文（Tweet）
a. 创建（Create）
b. 删除（Delete）
时间线/动态（Timeline/Feed）
a. 首页（Home）
b. 用户（User）
关注用户（Follow a user）
点赞推文（Like a tweet）
搜索推文（Search tweets）

非功能性需求

一致性（Consistency）

每一次读取操作都应该返回最近一次写入的数据，或者返回一个错误。
牺牲：最终一致性（Eventual consistency）。
这里指的是，为了保证系统的某些其他特性（如可用性或分区容错性），系统可能会在一段时间内允许数据不一致。
可用性（Availability）

每一次请求都应该得到一个（非错误）响应，但不保证该响应包含最近一次写入的数据。
可扩展性（Scalable）。
性能：低延迟（low Latency）。
分区容错性（Partition tolerance / Fault Tolerance）

即使节点之间的网络出现任意数量的消息丢失（或延迟），系统也能持续运行。
解释：

一致性（Consistency）：指的是数据在多个副本或节点之间保持一致的状态。
可用性（Availability）：指的是系统在任何时候都能响应请求的能力。
分区容错性（Partition tolerance）：指的是系统在部分节点失效或网络分区时仍能正常运行的能力。
CAP定理：

这些非功能性需求与著名的CAP定理密切相关。CAP定理指出，在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三个特性最多只能同时满足两个。
因此，在系统设计时，我们需要根据实际需求权衡这三个特性，并做出相应的选择。

### 步骤 2：容量估算

假设：

2 亿日活跃用户（DAU），1 亿条新推文。
每个用户：访问首页时间线 5 次，访问其他用户时间线 3 次。
每个时间线/页面有 20 条推文。
每条推文大小为 280 字节（140 个字符），元数据为 30 字节。
每张照片：200KB，20% 的推文包含图片。
每个视频：2MB，10% 的推文包含视频，30% 的视频会被观看。
解释：

容量估算 是系统设计面试中非常重要的一环，它能帮助我们了解系统需要处理的数据量和流量，从而为后续的系统设计提供依据。
在这个例子中，面试官给出了一个类似Twitter的社交媒体系统的假设场景，包括用户规模、推文数量、访问频率、数据大小等。
通过这些假设，我们可以计算出系统的存储需求、带宽需求、服务器数量等。
例如，可以计算出每天需要存储多少推文、照片和视频，每天需要处理多少时间线请求，以及需要多少带宽来传输数据。

存储估计

每日写入大小：
文本：
1 亿条新推文 * (280 + 30) 字节/推文 = 31GB/天
图片：
1 亿条新推文 * 20% 包含图片 * 200 KB/图片 = 4TB/天
视频：
1 亿条新推文 * 10% 包含视频 * 2MB/视频 = 20TB/天
总计：
31GB + 4TB + 6TB = 24TB/天
解释：

这张图是在进行系统设计时，为了计算系统每天需要存储的数据量而进行的估算。
它分解了不同类型的数据（文本、图片、视频）并分别进行了计算，最后得出了总的存储需求。
这里有一个计算错误，视频部分计算错误，应为20TB，所以总计部分也应为24TB。
重要性：
存储估计对于系统设计至关重要，因为它有助于我们了解需要多少存储空间，从而选择合适的存储解决方案。
这也有助于我们评估系统的成本和可扩展性。

带宽估计

每日读取推文量：

2 亿 * (5 次首页访问 + 3 次用户访问) * 20 条推文/页 = 320 亿条推文/天 （注意：这里原文有误，应为320亿，而不是32B）
每日读取带宽：

文本： 320 亿 * 280 字节 / 86400 秒 = 100MB/秒
图片： 320 亿 * 20% 推文包含图片 * 200 KB/图片 / 86400 秒 = 14GB/秒
视频： 320 亿 * 10% 推文包含视频 * 30% 被观看 * 2MB/视频 / 86400 秒 = 20GB/秒
总计： 35GB/秒
解释：

这张图是在进行系统设计时，为了计算系统需要的带宽而进行的估算。
它分解了不同类型的数据（文本、图片、视频）并分别进行了计算，最后得出了总的带宽需求。
重要性：
带宽估计对于系统设计至关重要，因为它有助于我们了解需要多少网络带宽，从而选择合适的网络架构和服务器。
这也有助于我们评估系统的性能和可扩展性。


### 步骤 3：系统 API 设计

系统API

postTweet ( userToken , string tweet ) ： 发布推文 (用户令牌，推文内容)
deleteTweet ( userToken , string tweetId ) ： 删除推文 (用户令牌，推文ID)
likeOrUnlikeTweet ( userToken , string tweetId , bool like ) ： 点赞或取消点赞推文 (用户令牌，推文ID，布尔值表示是否点赞)
readHomeTimeLine ( userToken , int pageSize , opt string pageToken ) ： 读取首页时间线 (用户令牌，页面大小，可选的页面令牌)
readUserTimeline ( userToken , int pageSize , opt string pageToken ) ： 读取用户时间线 (用户令牌，页面大小，可选的页面令牌)
解释：

这张图列出了一个类似Twitter的社交媒体系统的一些基本API。
API (Application Programming Interface) 是应用程序之间通信的接口。
这些API定义了客户端（例如，移动应用程序或网页应用程序）如何与服务器端交互，以执行诸如发布推文、删除推文、点赞推文、读取时间线等操作。
userToken 通常用于身份验证，以确保只有授权用户才能执行这些操作。
tweetId 是推文的唯一标识符。
pageSize 和 pageToken 用于分页，以便客户端可以分批获取时间线数据。
bool like 代表真假值，用于表示点赞或者取消点赞。

### 步骤 3：高层次设计

*   **架构图：** 绘制系统的高层次架构图，包括核心组件、模块以及它们之间的关系。
*   **技术选型：** 选择合适的技术栈，例如编程语言、数据库、缓存、消息队列等。
*   **核心模块：** 描述核心模块的功能和设计思路。

### 步骤 4：详细组件设计

*   **组件拆分：** 将高层次设计中的组件进一步拆分成更小的、可独立部署的模块。
*   **接口定义：** 定义模块之间的接口和数据交互格式。
*   **数据结构：** 设计合适的数据结构来存储和处理数据。

### 步骤 5：容错性 & 可扩展性

*   **容错设计：** 考虑系统可能出现的故障，例如服务器宕机、网络中断等，并设计相应的容错机制。
*   **扩展方案：** 设计系统的扩展方案，以应对未来的流量增长和功能扩展。
*   **伸缩性：** 考虑如何通过增加资源来提高系统的性能。
